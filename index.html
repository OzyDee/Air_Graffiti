<!DOCTYPE html>
<html lang="en">
<head>
  <!--
    AR Graffiti MVP — WebXR Hit-Test + Hold-to-Spray + GPS + Fallback
    -----------------------------------------------------------------
    What it does:
      • Starts an immersive-AR session (if supported) with hit-test to find a wall/floor.
      • Shows a reticle; while you hold the SPRAY button, we stamp semi-transparent
        "paint dots" (sprites) at the reticle pose so the paint sticks to the surface.
      • Lets you pick colour & size; Save Snapshot (PNG) and Save Metadata (JSON incl. GPS).
      • If WebXR AR isn't available, falls back to a simple 2D photo painter.

    Extend later:
      • Swap the sprite dot with your fan/drip brush textures.
      • Add layer system (per-surface group), cap presets, fan-strength, and pressure.
      • Persist anchors via a WebAR SDK (8th Wall / Lightship VPS) or go native (ARKit/ARCore).

    Requirements:
      • Serve over HTTPS (or localhost).
      • Chrome/Android for WebXR AR; iOS Safari will use the 2D fallback.
  -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>AR Graffiti MVP</title>

  <style>
    :root { --panel: rgba(0,0,0,.58); --accent:#6ee7ff; --fg:#fff; }
    html, body { margin:0; height:100%; background:#0b0f18; color:var(--fg); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    #overlay {
      position:fixed; inset:0; display:flex; flex-direction:column; justify-content:space-between; pointer-events:none;
    }
    .topbar, .bottombar {
      display:flex; gap:8px; align-items:center; padding:10px; background:var(--panel); backdrop-filter: blur(6px);
      pointer-events:auto; margin:10px; border-radius:12px;
    }
    .topbar { align-self: flex-start; }
    .bottombar { align-self: flex-end; }
    .btn {
      border:0; border-radius:12px; padding:10px 12px; background:#111827; color:#e5e7eb; font-weight:600;
    }
    .btn.primary { background:var(--accent); color:#08212a; }
    .btn.big { padding:14px 18px; font-size:16px; }
    .chip { font-size:12px; opacity:.9 }
    input[type="color"] { appearance:none; width:36px; height:36px; border-radius:50%; border:0; padding:0; background:transparent; }
    input[type="range"] { width:150px; }
    #arHint { position:fixed; left:50%; transform:translateX(-50%); bottom:10px; font-size:12px; opacity:.9; background:var(--panel); padding:8px 10px; border-radius:10px; }
    #fallback { position:fixed; inset:0; display:none; background:#0b0f18; }
    #fbCanvas { display:block; width:100%; height:100%; touch-action:none; }
    #unsupported { position:fixed; inset:auto 10px 10px 10px; background:var(--panel); padding:12px; border-radius:12px; display:none }
    a { color:#9de1ff; }
  </style>
</head>
<body>

  <!-- AR UI overlay (DOM Overlay for WebXR) -->
  <div id="overlay" aria-live="polite">
    <div class="topbar">
      <button id="startAR" class="btn primary">Start AR</button>
      <div class="chip" id="gpsChip">GPS: —</div>
      <div class="chip" id="statusChip">Status: idle</div>
    </div>

    <div class="bottombar">
      <label class="chip">Colour</label>
      <input id="paintColor" type="color" value="#6ee7ff" aria-label="Paint colour" />
      <label class="chip">Size</label>
      <input id="sizeRange" type="range" min="0.5" max="6" step="0.1" value="2.0" />
      <button id="spray" class="btn big">● Spray (hold)</button>
      <button id="snapshot" class="btn">Save Snapshot</button>
      <button id="saveMeta" class="btn">Save Metadata</button>
    </div>
  </div>

  <!-- Hint -->
  <div id="arHint">Move phone to scan; align the reticle with your wall, then hold “Spray”.</div>

  <!-- Fallback 2D Photo Painter -->
  <div id="fallback">
    <div class="topbar" style="position:absolute;left:10px;top:10px;z-index:10;">
      <label for="fileInput" class="btn primary" style="cursor:pointer;">Upload / Camera</label>
      <input id="fileInput" class="btn" type="file" accept="image/*" capture="environment" style="display:none;">
      <input id="fbColor" type="color" value="#6ee7ff"/>
      <label class="chip">Size</label><input id="fbSize" type="range" min="2" max="42" value="16" />
      <button id="fbSave" class="btn">Save PNG</button>
      <div class="chip">Fallback mode (no AR)</div>
    </div>
    <canvas id="fbCanvas"></canvas>
  </div>

  <div id="unsupported"></div>

  <!-- THREE.js (ESM) -->
  <script type="module">
    /**
     * AR Graffiti MVP — main module
     * - Sets up THREE WebGLRenderer with WebXR AR session + hit-test.
     * - Reticle indicates where paint will stick.
     * - Hold-to-spray adds sprites (decals) to the world at reticle pose.
     * - GPS captured on load (if available).
     * - Fallback 2D painter if WebXR AR isn't available.
     */
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.158.0/examples/jsm/webxr/ARButton.js';

    // ---------- DOM ----------
    const overlay   = document.getElementById('overlay');
    const startBtn  = document.getElementById('startAR');
    const sprayBtn  = document.getElementById('spray');
    const paintInp  = document.getElementById('paintColor');
    const sizeRange = document.getElementById('sizeRange');
    const statusChip= document.getElementById('statusChip');
    const gpsChip   = document.getElementById('gpsChip');
    const hint      = document.getElementById('arHint');
    const snapshot  = document.getElementById('snapshot');
    const saveMeta  = document.getElementById('saveMeta');
    const unsupportedBox = document.getElementById('unsupported');

    const fallbackDiv = document.getElementById('fallback');
    const fbCanvas = document.getElementById('fbCanvas');
    const fbSize   = document.getElementById('fbSize');
    const fbColor  = document.getElementById('fbColor');
    const fbSave   = document.getElementById('fbSave');
    const fileInput= document.getElementById('fileInput');

    // ---------- State ----------
    let renderer, scene, camera;
    let xrRefSpace = null;
    let hitTestSource = null;
    let hitTestInitialized = false;

    let reticle;
    let spraying = false;

    // paint settings
    let paintColor = new THREE.Color(paintInp.value);
    let paintSize  = parseFloat(sizeRange.value); // world units (approx. meters)

    // session metadata (simple)
    const meta = {
      startedAt: new Date().toISOString(),
      gps: null,
      stamps: 0
    };

    // ---------- GPS ----------
    if ('geolocation' in navigator) {
      navigator.geolocation.getCurrentPosition(
        pos => {
          meta.gps = {
            lat: pos.coords.latitude,
            lng: pos.coords.longitude,
            acc: pos.coords.accuracy
          };
          gpsChip.textContent = `GPS: ${meta.gps.lat.toFixed(5)}, ${meta.gps.lng.toFixed(5)} (±${Math.round(meta.gps.acc)}m)`;
        },
        err => { gpsChip.textContent = 'GPS: unavailable'; },
        { enableHighAccuracy:true, timeout:8000, maximumAge:5000 }
      );
    } else {
      gpsChip.textContent = 'GPS: not supported';
    }

    // ---------- Feature detect & boot ----------
    const xrOK = navigator.xr && await navigator.xr.isSessionSupported?.('immersive-ar');
    if (!xrOK) {
      // show fallback painter
      startFallbackPainter();
      showUnsupported('AR not supported on this device/browser. You can still paint on photos in fallback mode.');
    }

    // Wire UI regardless; Start AR will no-op in fallback.
    startBtn.addEventListener('click', () => { if(xrOK) initAR(); });
    paintInp.addEventListener('input', () => { paintColor.set(paintInp.value); });
    sizeRange.addEventListener('input', () => { paintSize = parseFloat(sizeRange.value); });

    sprayBtn.addEventListener('pointerdown', e => { spraying = true; sprayBtn.classList.add('primary'); });
    sprayBtn.addEventListener('pointerup',   e => { spraying = false; sprayBtn.classList.remove('primary'); });
    sprayBtn.addEventListener('pointerleave',e => { spraying = false; sprayBtn.classList.remove('primary'); });

    snapshot.addEventListener('click', saveSnapshot);
    saveMeta.addEventListener('click', () => downloadText(JSON.stringify(meta,null,2), `AR-Metadata-${new Date().toISOString().slice(0,19)}.json`));

    // ---------- AR Init ----------
    async function initAR(){
      statusChip.textContent = 'Status: starting AR…';
      // Scene + camera
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.xr.enabled = true;

      // Put Three's canvas behind our overlay
      document.body.appendChild(renderer.domElement);
      renderer.domElement.style.position = 'fixed';
      renderer.domElement.style.inset = '0';

      // Lighting (subtle, mostly for sprites if needed)
      const light = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
      scene.add(light);

      // Reticle mesh (ring)
      reticle = buildReticle();
      scene.add(reticle);

      // AR Button (uses DOM overlay root)
      const arBtn = ARButton.createButton(renderer, {
        requiredFeatures: ['hit-test', 'dom-overlay'],
        domOverlay: { root: document.body }
      });
      // Replace default ARButton with our "Start AR"
      arBtn.style.display = 'none';

      // Session start
      renderer.xr.addEventListener('sessionstart', onSessionStart);
      renderer.xr.addEventListener('sessionend', onSessionEnd);

      // Render loop
      renderer.setAnimationLoop(renderXR);

      window.addEventListener('resize', onWindowResize, { passive:true });
    }

    function onWindowResize(){
      if(!renderer || !camera) return;
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    async function onSessionStart(){
      statusChip.textContent = 'Status: scanning…';
      hint.style.display='block';

      const session = renderer.xr.getSession();
      xrRefSpace = await session.requestReferenceSpace('local');

      // Hit test source
      const viewerSpace = await session.requestReferenceSpace('viewer');
      const sources = await session.requestHitTestSource({ space: viewerSpace });
      hitTestSource = sources;
      hitTestInitialized = true;
    }

    function onSessionEnd(){
      statusChip.textContent = 'Status: ended';
      hitTestSource = null;
      hitTestInitialized = false;
      xrRefSpace = null;
      // keep the snapshot UI available
    }

    // ---------- Render loop ----------
    function renderXR(t, frame){
      if(!frame || !xrRefSpace) { renderer.render(scene, camera); return; }

      const session = renderer.xr.getSession();
      const pose = frame.getViewerPose(xrRefSpace);

      if (hitTestInitialized) {
        const hitRes = frame.getHitTestResults(hitTestSource);
        if (hitRes.length > 0) {
          const hit = hitRes[0];
          const hitPose = hit.getPose(xrRefSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(hitPose.transform.matrix);
          reticle.matrix.decompose(reticle.position, reticle.quaternion, reticle.scale);
          statusChip.textContent = 'Status: target locked';
          hint.style.display = 'none';

          if (spraying) {
            // Stamp a bunch of dots each frame for a spray feel
            for(let i=0;i<8;i++){
              addSprayDotAtReticle();
              meta.stamps++;
            }
          }
        } else {
          reticle.visible = false;
          statusChip.textContent = 'Status: scanning…';
          hint.style.display='block';
        }
      }

      renderer.render(scene, camera);
    }

    // ---------- Build helpers ----------
    function buildReticle(){
      const geo = new THREE.RingGeometry(0.06, 0.075, 32);
      const mat = new THREE.MeshBasicMaterial({ color: 0x80ffdd, opacity:0.9, transparent:true, side:THREE.DoubleSide });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = -Math.PI/2;
      mesh.visible = false;
      return mesh;
    }

    // Create (once) a small soft circular texture we tint per-sprite via material color
    const paintTexture = (() => {
      const c = document.createElement('canvas');
      c.width = c.height = 128;
      const ctx = c.getContext('2d');
      const grd = ctx.createRadialGradient(64,64,8, 64,64,64);
      grd.addColorStop(0, 'rgba(255,255,255,0.9)');
      grd.addColorStop(0.4, 'rgba(255,255,255,0.5)');
      grd.addColorStop(1, 'rgba(255,255,255,0.0)');
      ctx.fillStyle = grd;
      ctx.fillRect(0,0,128,128);
      const tex = new THREE.CanvasTexture(c);
      tex.minFilter = THREE.LinearFilter;
      return tex;
    })();

    function addSprayDotAtReticle(){
      if(!reticle || !reticle.visible) return;
      // Random small offset in reticle local space to emulate spray spread
      const spread = paintSize * 0.35;
      const rx = (Math.random()*2-1) * spread;
      const ry = (Math.random()*2-1) * spread;

      const spriteMat = new THREE.SpriteMaterial({
        map: paintTexture,
        color: paintColor,
        transparent: true,
        depthWrite: false
      });
      const sprite = new THREE.Sprite(spriteMat);

      // Place at reticle + offset in reticle's tangent plane
      const up = new THREE.Vector3(0,1,0);
      const normal = new THREE.Vector3(0,1,0);
      // Extract plane normal from reticle quaternion (assumes XZ plane reticle)
      normal.set(0,1,0).applyQuaternion(reticle.quaternion);

      const right = new THREE.Vector3(1,0,0).applyQuaternion(reticle.quaternion);
      const forward = new THREE.Vector3(0,0,1).applyQuaternion(reticle.quaternion);

      sprite.position.copy(reticle.position)
        .addScaledVector(right, rx)
        .addScaledVector(forward, ry);

      const s = paintSize * (0.7 + Math.random()*0.6);
      sprite.scale.setScalar(s);

      scene.add(sprite);
    }

    // ---------- Snapshot & Metadata ----------
    function saveSnapshot(){
      try{
        const data = renderer.domElement.toDataURL('image/png');
        downloadDataURL(data, `AR-Snapshot-${new Date().toISOString().slice(0,19)}.png`);
      }catch(e){
        alert('Snapshot failed (browser blocked readback). Try a regular screenshot.');
      }
    }
    function downloadDataURL(dataURL, filename){
      const a = document.createElement('a');
      a.href = dataURL; a.download = filename;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }
    function downloadText(text, filename){
      const blob = new Blob([text], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ---------- Fallback painter (2D photo) ----------
    function startFallbackPainter(){
      // Show fallback UI
      fallbackDiv.style.display = 'block';

      const ctx = fbCanvas.getContext('2d');
      let img = null, painting=false, last=null;

      function resize(){
        fbCanvas.width = window.innerWidth;
        fbCanvas.height= window.innerHeight;
        redraw();
      }
      function redraw(){
        ctx.fillStyle = '#0b0f18';
        ctx.fillRect(0,0,fbCanvas.width, fbCanvas.height);
        if(img){
          // Fit image
          const s = Math.min(fbCanvas.width/img.width, fbCanvas.height/img.height);
          const w = img.width*s, h=img.height*s;
          ctx.drawImage(img, (fbCanvas.width-w)/2, (fbCanvas.height-h)/2, w, h);
        }
      }
      window.addEventListener('resize', resize, {passive:true});
      resize();

      function stamp(x,y){
        const r = parseInt(fbSize.value,10);
        const g = ctx.createRadialGradient(x,y, r*0.1, x,y, r);
        const col = fbColor.value;
        g.addColorStop(0, hexToRgba(col, 0.9));
        g.addColorStop(0.5, hexToRgba(col, 0.5));
        g.addColorStop(1, hexToRgba(col, 0.0));
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      }
      function onDown(e){ painting=true; last=getXY(e); stamp(last.x,last.y); e.preventDefault(); }
      function onMove(e){ if(!painting) return; const p=getXY(e);
        const dx=p.x-last.x, dy=p.y-last.y; const d=Math.hypot(dx,dy);
        const step = Math.max(1, parseInt(fbSize.value,10)*0.4);
        const n = Math.ceil(d/step);
        for(let i=1;i<=n;i++){ const t=i/n; stamp(last.x+dx*t, last.y+dy*t); }
        last=p; e.preventDefault();
      }
      function onEnd(){ painting=false; last=null; }

      function getXY(e){
        const r=fbCanvas.getBoundingClientRect();
        const x = (e.touches? e.touches[0].clientX : e.clientX) - r.left;
        const y = (e.touches? e.touches[0].clientY : e.clientY) - r.top;
        return {x,y};
      }
      function hexToRgba(hex,a){
        const m=hex.match(/^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
        if(!m) return `rgba(255,255,255,${a})`;
        const r=parseInt(m[1],16), g=parseInt(m[2],16), b=parseInt(m[3],16);
        return `rgba(${r},${g},${b},${a})`;
        }

      fbCanvas.addEventListener('pointerdown', onDown, {passive:false});
      fbCanvas.addEventListener('pointermove', onMove, {passive:false});
      fbCanvas.addEventListener('pointerup',   onEnd,  {passive:true});
      fbCanvas.addEventListener('pointercancel',onEnd, {passive:true});
      fbCanvas.addEventListener('pointerleave', onEnd, {passive:true});

      fileInput.addEventListener('change', (ev)=>{
        if(!ev.target.files || !ev.target.files[0]) return;
        const reader = new FileReader();
        reader.onload = e=>{
          const _img = new Image();
          _img.onload = ()=>{ img=_img; redraw(); };
          _img.src = e.target.result;
        };
        reader.readAsDataURL(ev.target.files[0]);
      });

      fbSave.addEventListener('click', ()=>{
        const a=document.createElement('a');
        a.download = `PhotoPaint-${new Date().toISOString().slice(0,19)}.png`;
        a.href = fbCanvas.toDataURL('image/png');
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
      });
    }

    function showUnsupported(msg){
      unsupportedBox.style.display='block';
      unsupportedBox.innerHTML = `<b>Heads up:</b> ${msg}<br/><br/>
        <small>For true world-anchored AR on iPhone/iPad, consider a WebAR SDK (8th Wall / Niantic Lightship) or a native app (ARKit) with GeoAnchors.</small>`;
    }
  </script>
</body>
</html>
